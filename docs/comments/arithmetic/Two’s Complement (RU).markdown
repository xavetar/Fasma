Термин результат общего свойства, обладающего моментом **схлопывания**, предполагающий **симметричное соотношение величин в бинарной логико-арифметической форме**, при **операциях над отражениями**. Кодирует не числа, знаки или операции, термин выражает форму **линейного соотношения** между **бинарным представлением**, выраженным с помощью **логического приведения инверсии** к **симметричному** и **тождественному** соотношению **симметричных линейных величин**, способных быть выраженными, как **линейное симметричное соотношение**, через **операции над отражениями**:

1) Где **расширение и сжатие** сохраняет **пропорции** подразумевая, что **линейное соотношение** уже **предопределено** над этими **линейными величинами**
2) Где результат **операции** над **линейными величинами** предполагает возможность быть выраженным через **линейное соотношение**
3) Где результат **операции** логико-арифметически предполагает **симметрию** или возможность быть выраженным через **симметричное соотношение**
4) Где **симметричное соотношение линейных величин** - выражено симметрично, относительно одной **числовой плоскости**
5) Где **линейное соотношение** определяется не абсолютным **бинарным представлением**, а своим **положением** и **направлением** относительно **фиксированного** центра нейтральной точки на **числовой плоскости**
6) Где **интерпретация** определяет значение **линейного соотношения** величин (signed, unsigned)

Форма **логически** выражающая **результат инверсии**, через привидение его к симметричной **логико-арифметической** операции (`подгоняя логико-арифметически её результат, под ответ`). Дискретно выражая непрерывное соотношение **линейных величин и их симметричных или асимметричных соотношений**, способных быть выраженными **симметрично**. Независимо от того, будет ли над формой определена **арифметика**, **логика** или **вообще ничего**.

## Определения

- **Комплиментарность** — это **асимметричное отражение**, подчиняющееся тождеству связности, стремящееся к **аннигиляции** исходной структуры до состояния покоя (ноля или другого определения покоя).
- **Схлопывание** — точка сингулярности, начала и конца `отражения`.
- **Тождество связности** —  для `i8`/`u8`, **(~V + 0x01) ≡ ~(V - 0x01)** ≡ **(~V - 0xFF) ≡ ~(V + 0xFF)** , отражает формирование и отмену, расширение и сжатие, определяет связность **асимметричных отражений** (как `abs` и `backward abs` или `V ⇌ -V`)  - отражающее `фазу` смещения относительно момента/центра инверсии.
- **Цикличность поля** — для `i8`/`u8`, поле замкнуто в кольце, где `V + 0x01 ⇌ V - 0xFF` ≡ `V - 0x01 ⇌ V + 0xFF` или `+1 = -255` ⇌ `-1 = +255`, взаимная эквивалентность представлений (действительно для симуляций использующих инструкции **TC** для **знаковых** и **без знаковых** типов данных).
- **Операции над отражением** - производя операции над отражениями в 8-битном кольце, значения полностью уничтожают друг друга (**схлопываются**):

    - Для знаковых отражений (`[-128, -1] => [-128, 127] => [0, 127]`):

        1) Сложение (**расширение**) в паре с `отражениями` (`A = V`, `B = -V`):
            
                - `-x = ~(B - 1) = ~(B + 255)`:
                
                    **A ⊕ B** ≡ **A ⊖ ¬(B ⊖ 1)**
                    **A + B** ≡ **A - ~(B - 1)**
                    
                    **A ⊕ B** ≡ **A ⊖ ¬(B ⊕ 255)**
                    **A + B** ≡ **A - ~(B + 255)**
                
                - `-x = (~B + 1) = (~B - 255)`:
                
                    **A ⊕ B** ≡ **A ⊖ (¬B ⊕ 1)**
                    **A + B** ≡ **A - (~B + 1)**
                    
                    **A ⊕ B** ≡ **A ⊖ (¬B ⊖ 255)**
                    **A + B** ≡ **A - (~B - 255)** 
                
        1) Вычитание (**сжатие**) в паре с `числом` (`A = V`, `B = V`):
            
                - `-x = ~(B - 1) = ~(B + 255)`:
                
                    **A ⊖ B** ≡ **A ⊕ ~(B ⊖ 1)**
                    **A - B** ≡ **A + ~(B - 1)**
                    
                    **A ⊖ B** ≡ **A ⊕ ~(B ⊕ 255)**
                    **A - B** ≡ **A + ~(B + 255)**
                    
                - `-x = (~B + 1) = (~B - 255)`:
                
                    **A ⊖ B** ≡ **A ⊕ (~B ⊕ 1)**
                    **A - B** ≡ **A + (~B + 1)**
                    
                    **A ⊖ B** ≡ **A ⊕ (~B ⊖ 255)**
                    **A - B** ≡ **A + (~B - 255)**

    - Для без знаковых отражений (`[0, 255]`):

        1) Сложение (**расширение**) в паре с `отражениями (величинами отражений - обратно пропорциональным - величинам присутствия)` (`A = V`, `B = -V`):
            
                - `-x = ~(B - 1) = ~(B + 255)`:
                
                    **A ⊕ B** ≡ **A ⊖ ¬(B ⊖ 1)** 
                    **A + B** ≡ **A - ~(B - 1)**
                    
                    **A ⊕ B** ≡ **A ⊖ ¬(B ⊕ 255)**
                    **A + B** ≡ **A - ~(B + 255)**
                
                - `-x = (~B + 1) = (~B - 255)`:
                
                    **A ⊕ B** ≡ **A ⊖ (¬B ⊕ 1)**
                    **A + B** ≡ **A - (~B + 1)** 
                    
                    **A ⊕ B** ≡ **A ⊖ (¬B ⊖ 255)**
                    **A + B** ≡ **A - (~B - 255)**
            
            Сложение вверх, не создаёт ловушку имитации **без знаковой** логики **LPU:LAU:ALU** и **TC**, через её симуляцию.
            
        1) Вычитание (**сжатие**) в паре с `числом` (`A = V`, `B = V`):
                
                - `-x = ~(B - 1) = ~(B + 255)`:
                
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊕ 1) } else { A ⊕ ¬(B ⊖ 1) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { ~A + (B + 1) } else { A + ~(B - 1) }**
                    
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊖ 255) } else { A ⊕ ¬(B ⊕ 255) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { ~A + (B - 255) } else { A + ~(B + 255) }**
                    
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊕ 1) } else { A ⊕ ¬(B ⊖ 1) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { B + (~A + 1) } else { A + ~(B - 1) }**
                    
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊖ 255) } else { A ⊕ ¬(B ⊕ 255) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { B + (~A - 255) } else { A + ~(B + 255) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊕ 1) } else { A ⊕ ¬(B ⊖ 1) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { ~A + (B + 1) } else { A + ~(B - 1) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊖ 255) } else { A ⊕ ¬(B ⊕ 255) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { ~A + (B - 255) } else { A + ~(B + 255) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊕ 1) } else { A ⊕ ¬(B ⊖ 1) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { B + (~A + 1) } else { A + ~(B - 1) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊖ 255) } else { A ⊕ ¬(B ⊕ 255) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { B + (~A - 255) } else { A + ~(B + 255) }**
                
                - `-x = (~B + 1) = (~B - 255)`:
                
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊕ 1) } else { A ⊕ (¬B ⊕ 1) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { ~A + (B + 1) } else { A + (~B + 1) }**
                    
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊖ 255) } else { A ⊕ (¬B ⊖ 255) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { ~A + (B - 255) } else { A + (~B - 255) }**
                    
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊕ 1) } else { A ⊕ (¬B ⊕ 1) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { B + (~A + 1) } else { A + (~B + 1) }**
                    
                    **if A < B { B ⊖ A } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊖ 255) } else { A ⊕ (¬B ⊖ 255) }**
                    **if A < B { B - A } else { A - B }** ≡ **if A < B { B + (~A - 255) } else { A + (~B - 255) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊕ 1) } else { A ⊕ (¬B ⊕ 1) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { ~A + (B + 1) } else { A + (~B + 1) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { ¬A ⊕ (B ⊖ 255) } else { A ⊕ (¬B ⊖ 255) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { ~A + (B - 255) } else { A + (~B - 255) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊕ 1) } else { A ⊕ (¬B ⊕ 1) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { B + (~A + 1) } else { A + (~B + 1) }**
                    
                    **if A < B { ¬A ⊖ ¬B } else { A ⊖ B }** ≡ **if A < B { B ⊕ (¬A ⊖ 255) } else { A ⊕ (¬B ⊖ 255) }**
                    **if A < B { ~A - ~B } else { A - B }** ≡ **if A < B { B + (~A - 255) } else { A + (~B - 255) }**
            
            - Дополнительные формулы: `A < B` : `~(A - ~B)`, `~(A - B) + 1,` `~(A + ~(B - 1)) + 1`, `~(A + (~B + 1)) + 1`, `~(A + ~(B + 255)) - 255`, `~(A + (~B - 255)) - 255`.
            
            Вычитание вниз, создаёт ловушку имитации **без знаковой** логики **LPU:LAU:ALU** и **TC**, через её симуляцию. Вычитание в **без знаковой** логике, соответствует **абсолютной дистанции** между числами.
            
            Через математику **TC** объясняют кольцом **ℤ/ℤ₂₅₆**, (`где заём возникает из 'виртуального бита': 2^8 для 8 битных чисел`), однако **математика** обладает симметрией и является производной **арифметики**, основанной на **логике** и любое **арифметико-математическое** обоснование - является **неполным и вторичным**. Использовать **математику, арифметику** для доказательства **логики**, подобному идее: `использовать гвозди, чтобы рубить топор`.
            Компиляторы используют упрощённую **логику** для **без знаковых** типов данных - создавая условия для возникновения **логической ошибки симуляции (для без знаковых типов данных)**: `0 (0x00) - 255 (0xFF) = 1 (0x01)`, что логически эквивалентно **закону двойного отрицания** (`инволюции`) для чисел со знаком: `0 (0x00) - (-1) (0xFF) = 1 (0x01)`.
            Ироничная шутка: `У друга было 0x00 рублей, отдав другу 0xFF рублей, сколько денег у него сейчас?`.
            
        Переполнение вниз **запрещено**! В **без знаковой** арифметике, нельзя говорить об **отсутствии** чего-то, только о **наличии**. Однако **отсутствие** чего-то - **выражается наличием противоположного (этого)**.

## Описание

**Симметричное отражение** бинарного представления **линейной величины**, воспроизводится с помощью **логических тождеств** (арифметических операций выраженных через логику, приводящих к симметричному отображению **линейных величин** на **числовой плоскости**, в результате возникает **конформность** между **логикой и арифметикой**):

- `-x = (~B + 1) = (~B - 255)`:

    - Для знаковых отражений (`[-128, -1] => [-128, 127] => [0, 127]`):
        
    1) Логико-алгоритмическое добавление единицы к инвертированному **положительному числу**, реактивно формирует **комплиментарное представление** (`исправляет случившееся искажение, для симметрии линейного соотношения`). Приближая число к **0**, компенсируя **арифметическую асимметрию логической инверсии** относительно **числовой плоскости** для последующей операции над **линейными отражениями величин**, внутри **числовой плоскости**: `(~1 + 1) = -1 (0xFF)`
    2) Логико-алгоритмическое добавление единицы к инвертированному **отрицательному числу**, реактивно формирует **комплиментарное представление** (`исправляет случившееся искажение, для симметрии линейного соотношения`). Отдаляя число от **0**, компенсируя **арифметическую асимметрию логической инверсии** относительно **числовой плоскости** для последующей операции над **линейными отражениями величин**, внутри **числовой плоскости**: `(~-1 + 1) = 1 (0x01)`
    
    - Для без знаковых отражений (`[0, 255]`):
        
    1) Логико-алгоритмическое добавление единицы к инвертированному **числу**, реактивно формирует **величину отражения обратно пропорциональную величине присутствия** (`исправляет случившееся искажение, для симметрии линейного соотношения`). Компенсируя **арифметическую асимметрию логической инверсии** относительно **числовой плоскости** для последующей операции над **линейными отражениями величин**, внутри **числовой плоскости**: `(~1 + 1) = 255 (0xFF)`

- `-x = ~(B - 1) = ~(B + 255)`:

    - Для знаковых отражений (`[-128, -1] => [-128, 127] => [0, 127]`):
        
    1) Логико-алгоритмическое вычитание единицы из **положительного числа**, до инверсии, проактивно формирует **комплиментарное представление** (`подготавливая искажение, для симметрии линейного соотношения`). Приближая число к **0**, после инверсии, компенсируя **арифметическую асимметрию логической инверсии** относительно **числовой плоскости** для последующей операции над **линейными отражениями величин**, внутри **числовой плоскости**: `~(1 - 1) = -1 (0xFF)`, `~(1 - 1) = 255 (0xFF)`
    2) Логико-алгоритмическое вычитание единицы из **отрицательного числа**, до инверсии, проактивно формирует **комплиментарное представление** (`подготавливая искажение, для симметрии линейного соотношения`), Отдаляя число от **0**, после инверсии, компенсируя **арифметическую асимметрию логической инверсии** относительно **числовой плоскости** для последующей операции над **линейными отражениями величин**, внутри **числовой плоскости**:: `~(-1 - 1) = 1 (0x01)`
    
    - Для без знаковых отражений (`[0, 255]`):
        
    1) Логико-алгоритмическое вычитание единицы из **числа**, до инверсии, проактивно формирует **комплиментарное представление** (`подготавливая искажение, для симметрии линейного соотношения`). Компенсируя **арифметическую асимметрию логической инверсии** относительно **числовой плоскости** для последующей операции над **линейными отражениями величин**, внутри **числовой плоскости**: `(~1 + 1) = 255 (0xFF)`

## Фундаментальные преобразования

### Формулы (SFG = `i8`/`u8`)

Сложение (`a + b`): **a - ~(b - 0x01) ≡ a - (~b + 0x01)** ⇌ **a - ~(b + 0xFF) ≡ a - (~b - 0xFF)**

Вычитание (`a - b`): **a + (~b + 0x01) ≡ a + ~(b - 0x01)** ⇌ **a + (~b - 0xFF) ≡ a + ~(b + 0xFF)**

#### Сложение

##### Тип данных: `i8`/`u8` (что происходит внутри аппаратных инструкций основанных на **TC**)

| a   | b   | a + b = a + b (HEX)                | Результат |
| --- | --- | ---------------------------------- | --------- |
| 5   | 3   | `5 + 3 = 0x05 + 0x03 = 0x08`       | 8         |
| 5   | -3  | `5 + (-3) = 0x05 + 0xFD = 0x02`    | 2         |
| -5  | -3  | `(-5) + (-3) = 0xFB + 0xFD = 0xF8` | -8        |

| a   | b   | a + b = a - ~(b - 1) (HEX)                     | Результат |
| --- | --- | ---------------------------------------------- | --------- |
| 5   | 3   | `5 + ~(3 - 1) = 0x05 - ~(0x03 - 1) = 0x08`     | 8         |
| 5   | -3  | `5 + ~(-3 - 1) = 0x05 - ~(0xFD - 1) = 0x02`    | 2         |
| -5  | -3  | `(-5) + ~(-3 - 1) = 0xFB - ~(0xFD - 1) = 0xF8` | -8        |

| a   | b   | a + b = a - ~(b + 255) =  a - ~(b + (-1)) (HEX)                              | Результат |
| --- | --- | ---------------------------------------------------------------------------- | --------- |
| 5   | 3   | `5 - ~(3 + 255) = 5 - ~(3 + (-1)) = 0x05 - ~(0x03 - 1) = 0x08`               | 8         |
| 5   | -3  | `5 - ~((-3) + 255) = = 5 - ~((-3) + (-1)) = 0x05 - ~(0xFD - 1) = 0x02`       | 2         |
| -5  | -3  | `(-5) - ~((-3) + 255) = = (-5) - ~((-3) + (-1)) = 0xFB - ~(0xFD - 1) = 0xF8` | -8        |

| a   | b   | a + b = a - (~b + 1) (HEX)                       | Результат |
| --- | --- | ------------------------------------------------ | --------- |
| 5   | 3   | `5 - (~3 + 1) = 0x05 - ~(0x03 - 1) = 0x08`       | 8         |
| 5   | -3  | `5 - (~(-3) + 1) = 0x05 - ~(0xFD - 1) = 0x02`    | 2         |
| -5  | -3  | `(-5) - (~(-3) + 1) = 0xFB - ~(0xFD - 1) = 0xF8` | -8        |

| a   | b   | a + b = a - (~b - 255) = a - (~b - (-1)) (HEX)                             | Результат |
| --- | --- | -------------------------------------------------------------------------- | --------- |
| 5   | 3   | `5 - (~3 - 255) = 5 - (~3 - (-1)) = 0x05 - ~(0x03 - 1) = 0x08`             | 8         |
| 5   | -3  | `5 - (~(-3) - 255) = 5 - (~(-3) - (-1)) = 0x05 - ~(0xFD - 1) = 0x02`       | 2         |
| -5  | -3  | `(-5) - (~(-3) - 255) = (-5) - (~(-3) - (-1)) = 0xFB - ~(0xFD - 1) = 0xF8` | -8        |

#### Вычитание

##### Тип данных: `i8`/`u8` (что происходит внутри аппаратных инструкций основанных на **TC**)

| a   | b   | a - b = a - b (HEX)                | Результат |
| --- | --- | ---------------------------------- | --------- |
| 5   | 3   | `5 - 3 = 0x05 - 0x03 = 0x02`       | 2         |
| 5   | -3  | `5 - (-3) = 0x05 - 0xFD = 0x08`    | 8         |
| -5  | -3  | `(-5) - (-3) = 0xFB - 0xFD = 0xFE` | -2        |

| a   | b   | a - b = a + (~b + 1) (HEX)              | Результат |
| --- | --- | --------------------------------------- | --------- |
| 5   | 3   | `5 + (~3 + 1) = 0x05 + 0xFD = 0x02`     | 2         |
| 5   | -3  | `5 + (~(-3) + 1) = 0x05 + 0x03 = 0x08`    | 8         |
| -5  | -3  | `(-5) + (~(-3) + 1) = 0xFB + 0x03 = 0xFE` | -2        |

| a   | b   | a - b = a + (~b - 255) = a + (~b - (-1)) (HEX)                      | Результат |
| --- | --- | ------------------------------------------------------------------- | --------- |
| 5   | 3   | `5 + (~3 - 255) = 5 + (~3 - (-1)) = 0x05 + 0xFD = 0x02`             | 2         |
| 5   | -3  | `5 + (~(-3) - 255) = 5 + (~(-3) - (-1)) = 0x05 + 0x03 = 0x08`       | 8         |
| -5  | -3  | `(-5) + (~(-3) - 255) = (-5) + (~(-3) - (-1)) = 0xFB + 0x03 = 0xFE` | -2        |

| a   | b   | a - b = a + ~(b - 1) (HEX)              | Результат |
| --- | --- | --------------------------------------- | --------- |
| 5   | 3   | `5 + ~(3 - 1) = 0x05 + 0xFD = 0x02`     | 2         |
| 5   | -3  | `5 + ~(-3 - 1) = 0x05 + 0x03 = 0x08`    | 8         |
| -5  | -3  | `(-5) + ~(-3 - 1) = 0xFB + 0x03 = 0xFE` | -2        |

| a   | b   | a - b = a + ~(b + 255) = a + ~(b + (-1)) (HEX)                      | Результат |
| --- | --- | ------------------------------------------------------------------- | --------- |
| 5   | 3   | `5 + ~(3 + 255) = 5 + ~(3 + (-1)) = 0x05 + 0xFD = 0x02`             | 2         |
| 5   | -3  | `5 + ~((-3) + 255) = 5 + ~((-3) + (-1)) = 0x05 + 0x03 = 0x08`       | 8         |
| -5  | -3  | `(-5) + ~((-3) + 255) = (-5) + ~((-3) + (-1)) = 0xFB + 0x03 = 0xFE` | -2        |

Неявно возникает **тождество** для **линейных симметричных соотношений** (когда `left operand < right operand`):

1) `0_u8 - 255_u8 => 0_i8 - (-1_i8) = 1`
2) `0_u8 - 1_u8 => 0_i8 - 1_i8 = -1`

Что раскрывается в **ошибку имитации без знаковых типов данных**, в **без знаковой** арифметике, нельзя говорить об **отсутствии** чего-то, только о **наличии**.

## Операции в модели (ЯП)

| Задача                                                        | Формула                                                            | Примечание                                                                                                                        |
| ------------------------------------------------------------- | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------- |
| Принудительное формирование дополненного представления из `v` | `N = ilog2(V) + 1`<br>`R = ((-1) ^ V) ^ ((1 << N) - 1)`            | Применимо, когда в другой среде число имело иное представление с расширением знака (байтовый поток, C, Rust, аппаратный регистр). |
| Формирование и отмена комплиментарного представления          | `R = (~V + 1)` ≡ `R = (~R + 1)`<br>`R = ~(V - 1)` ≡ `R = ~(R - 1)` | Применимо, для тождественных преобразований внутри стандартного асимметричного набора определений.                                |

## Примеры минимальных функций

### Формализация abs (|x|)

#### Общая идея алгоритма (при наличии инструкции знакового распространения):

- Для 32-бит:

1. x >> 31 → арифметический сдвиг вправо (в отличие от логичекого (sll, srl), распостраняет знак)
        → старший бит (знак) растягивается (sra, без sla - знак в начале регистра и sla противоречит архитектуре x86)
        → для отрицательного: 0xFFFFFFFF (-1)
        → для положительного: 0x00000000 (0)
2. (x ^ mask) - mask
        → если x ≥ 0 и x ≤ (2**(32-1) - 1):
            (x ^ 0) - 0 = x - 0 = x
        → если x ≥ -1 ^ (2**(32-1) - 1) и x ≤ 0:
            (-1 ^ x) + 1 = ~x - (-1) = ~x + 1

#### Реализация:

- Эквивалент в C:

```c
static inline __attribute__((always_inline, used))
int8_t abs(int8_t x) {
    /*
    Корректное |x| для значения в two's complement
    */
    if (x < 0) { return !x + 0x01; } else { return x; }
}
```

```c
static inline __attribute__((always_inline, used))
int8_t abs(int8_t x) {
    /*
    Корректное |x| для значения в two's complement
    */
    int8_t mask = x >> 7;
    return (mask ^ x) - mask;
}
```

- Эквивалент в Rust:

```rust
#[unsafe(no_mangle)]
fn abs(x: i8) -> i8 {
    /*
    Корректное |x| для значения в two's complement
    */
    if x < 0 { return !x + 0x01; } else { return x; }
}
```

```rust
#[unsafe(no_mangle)]
fn abs(x: i8) -> i8 {
    /*
    Корректное |x| для значения в two's complement
    */
    let mask: i8 = x >> 7;
    return ((mask ^ x) - mask);
}
```

- Эквивалент в Python:

```python
def abs_two_complement(x: int, bits: int = 32) -> int:
    """
    Корректное |x| для значения в two's complement (до ±2^{bits-1}).
    """
    min_u: int = -1 ^ ((1 << (bits - 1)) - 1)
    max_u: int = 0 ^ ((1 << (bits - 1)) - 1)
    if not (min_u <= x <= max_u):
        raise ValueError("Value out of signed bits-bit range")
    # Старший бит знаковый = 1
    if x >> (bits - 1):
        return (((-1) ^ x) + 1) & max_u
    return x
```

- Эквивалент в Python:

```python
def abs_two_complement(x: int, bits: int = 32) -> int:
    """
    Корректное |x| для значения в two's complement (покрывая ±2^{bits})-1).
    """
    min_u: int = -1 ^ ((1 << bits) - 1)
    max_u: int = 0 ^ ((1 << bits) - 1)
    if not (min_u <= x <= max_u):
        raise ValueError("Value out of unsigned bits-bit range")
    # Старший бит знаковый = 1
    if x >> (bits - 1):
        x = (-1 ^ x) + 1
        # Гарантируем положительный результат
        return x & ((1 << (bits - 1)) - 1)
    return x
```

### Формализация babs (-x)

#### Реализация:

- Эквивалент в C:

```c
static inline __attribute__((always_inline, used))
int8_t babs(int8_t x) { // -x
    /*
    Корректное -x для значения в two's complement
    */
    return ~x + 0x01;
}
```

```c
static inline __attribute__((always_inline, used))
uint8_t babs(uint8_t x) {
    /*
    Корректно возвращает величину отражения обратно пропорциональную величине присутствия для беззнакового типа данных в two's complement
    */
    return ~x + 0x01;
}
```

- Эквивалент в Rust:

```rust
#[unsafe(no_mangle)]
#[inline(always)]
fn babs(x: i8) -> i8 { // -x
    /*
    Корректное -x для значения в two's complement
    */
    return !x + 0x01;
}
```

```rust
#[unsafe(no_mangle)]
#[inline(always)]
fn babs(x: u8) -> u8 { // -x
    /*
    Корректно возвращает величину отражения обратно пропорциональную величине присутствия для беззнакового типа данных в two's complement
    */
    return !x + 0x01;
}
```

- Эквивалент в Python:

```python
def babs(x: int, bits: int = 32) -> int: # -x
    """
    Корректное -x для значения в two's complement (до ±2^{bits-1})
    """
    min_u: int = -1 << (bits - 1)
    max_u: int = (1 << (bits - 1)) - 1
    if not (min_u <= x <= max_u):
        raise ValueError("Value out of signed bits-bit range")
    # Старший бит знаковый = 1
    if x >> (bits - 1):
        if x == min_u:
            return min_u
        else:
            return (((-1) ^ x) + 1) & max_u
    else:
        return (((-1) ^ x) + 1) | min_u
```

```python
def babs(x: int, bits: int = 32) -> int: # -x
    """
    Корректное -x для значения в two's complement (покрывая ±2^{bits})-1)
    """
    min_u: int = -1 << bits
    max_u: int = (1 << bits) - 1
    if not (min_u <= x <= max_u):
        raise ValueError("Value out of unsigned bits-bit range")
    # Старший бит знаковый = 1
    if x >> (bits - 1):
        if x == min_u:
            return min_u
        else:
            return (((-1) ^ x) + 1) & max_u
    else:
        return (((-1) ^ x) + 1) | min_u
```

### Формализация nabs (-|x|)

#### Реализация:

- Эквивалент в C:

```c
#include <stdint.h>

int8_t nabs(uint8_t x) {
    /*
    Корректное negative abs для значения
    */
    if (x <= UINT8_C(0x80)) {
        return (int8_t) (~x + UINT8_C(0x01));
    } else {
        return (int8_t) x;
    }
}
```

```c
#include <stdint.h>

int8_t nabs(uint8_t x) {
    /*
    Корректное negative abs для значения
    */
    if (x <= UINT8_C(0x80)) {
        return (int8_t) (~x + UINT8_C(0x01));
    } else {
        return (int8_t) (~(~x - UINT8_MAX) + UINT8_C(0x01));
    }
}
```

- Эквивалент в Rust:

```rust
#[unsafe(no_mangle)]
fn nabs(x: u8) -> i8 {
    /*
    Корректное negative abs для значения
    */
    if x <= 0x80 {
        return (!x + 0x01) as i8;
    } else {
        return (x as i8);
    }
}
```

```rust
#[unsafe(no_mangle)]
fn nabs(x: u8) -> i8 {
    /*
    Корректное negative abs для значения
    */
    if x <= 0x80 {
        return (!x + 0x01) as i8;
    } else {
        return (!(!x - u8::MAX) + 0x01) as i8;
    }
}
```

### Интерпретация отрицательного представления из поля переменной гаммы

#### Реализация:

- Эквивалент в C:

```c
#include <stdint.h>

static inline __attribute__((always_inline, used))
int8_t uas(uint8_t x) {
    /*
    Корректное unsigned as signed для значения
    */
    if (x == 0) { return x; }
    return (int8_t) (
        (
            UINT8_C(0xFF) ^ x
        ) ^ (
            (uint8_t) ((0x0001U << (0x0020U - __builtin_clz(x))) - 0x0001U)
        )
    );
}
```

```c
#include <stdint.h>

static inline __attribute__((always_inline, used))
int8_t uas(uint8_t x) {
    /*
    Корректное unsigned as signed для значения, распространяющее знак
    */
    return (int8_t) (
        (
            UINT8_C(0xFF) ^ x
        ) ^ (
            (x | x >> 1)
        | ((x | x >> 1) >> 2)
        | (((x | x >> 1) | ((x | x >> 1) >> 2)) >> 4)
        )
    );
}
```

```c
#include <stdint.h>

static inline __attribute__((always_inline, used)) 
int64_t uas(uint64_t value, uint8_t sfg) {
    /* 
    * sign_shift: дистанция до края числовой плоскости.
    * Мы используем 64 бит (0x40), вычитая длину под-поля.
    * Маскировка (sfg & 0x3F) гарантирует, что мы не выйдем за пределы 63.
    * Пример (sub-field group): SFG = 8 (для uint8_t)
    */
    uint8_t sign_shift = UINT8_C(0x0040) - (sfg & UINT8_C(0x3F));

    /*
    * 1. Сдвиг влево выносит знаковый бит под-поля в позицию знакового бита i64.
    * 2. Арифметический сдвиг вправо «затягивает» этот бит обратно, 
    *    заполняя пустоту и восстанавливая линейную симметрию (распространяя знак).
    */
    return (((int64_t) value) << sign_shift) >> sign_shift;
}
```

- Эквивалент в Rust:

```rust
#[unsafe(no_mangle)]
#[inline(always)]
fn uas(x: u8) -> i8 {
    /*
    Корректное unsigned as signed для значения, распространяющее знак
    */
    return (
        (
            0xFF_u8 ^ x
        ) ^ (
            (
                (0x00000001_u32 << (0x00000008_u32 - x.leading_zeros())) - 0x00000001_u32
            ) as u8
        )
    ) as i8;
}
```

```rust
#[unsafe(no_mangle)]
#[inline(always)]
fn uas(x: u8) -> i8 {
    /*
    Корректное unsigned as signed для значения, распространяющее знак
    */
    return (
        (
            0xFF_u8 ^ x
        ) ^ (
            (
                (0x00000001_u32 << (x.ilog2() + 0x00000001_u32)) - 0x00000001_u32
            ) as u8
        )
    ) as i8;
}
```

```rust
#[unsafe(no_mangle)]
#[inline(always)]
fn uas(x: u8) -> i8 {
    /*
    Корректное unsigned as signed для значения, распространяющее знак
    */
    return (
        (
            0xFF_u8 ^ x
        ) ^ (
            (x | x >> 1)
        | ((x | x >> 1) >> 2)
        | (((x | x >> 1) | ((x | x >> 1) >> 2)) >> 4)
        )
    ) as i8;
}
```

```rust
#[unsafe(no_mangle)]
#[inline(always)]
pub const fn uas<const SFG: u8>(value: u128) -> i128 {
    /*
    Корректное unsigned as signed для значения любой длины под-поля внутри длины поля типа данных, распространяющее знак
    */
    let sign_shift: i128 = 0x80_i128 - (SFG & 0x7F_u8) as i128;
    return ((value as i128) << sign_shift) >> sign_shift;
}
```

- Эквивалент в Python:

```python
def uas(x: int, bits: int) -> int:
    min_u: int = 0
    max_u: int = (1 << n) - 1
    if not (min_u <= x <= max_u):
        raise ValueError("Value out of signed bits-bit range")
    return ((-1) & (-1 << n)) | x
```

```python
def uas(x: int, bits: int) -> int:
    min_u: int = 0
    max_u: int = (1 << n) - 1
    if not (min_u <= x <= max_u):
        raise ValueError("Value out of signed bits-bit range")
    return (((-1) ^ x) ^ ((1 << n) - 1))
```

## Лицензия

Файл является частью проекта [Fasma](https://github.com/xavetar/Fasma). Распространяется под лицензиями Anti-Virus, MIT и Apache (версия 2.0). Подробности см. в файле [LICENSE](https://github.com/xavetar/Fasma/blob/main/LICENSE).

## Автор

Developed by [Stanislav Mikhailov (xavetar)](https://github.com/xavetar/).
