# Консолидированный Анализ Реализаций `_mm_cmpgt_epu64` и `_mm_cmpgt_epi64`

Функции `_mm_cmpgt_epu64` и `_mm_cmpgt_epi64` выполняют сравнение 64-битных чисел без знака и со знаком, соответственно, между двумя векторами `__m128i`, `a` и `b`, в SSE2, где прямые инструкции для 64-битного сравнения отсутствуют. Обе функции создают маску: `0xFFFFFFFFFFFFFFFF` для каждой 64-битной линии, где `a > b`, и `0x0000000000000000`, где `a ≤ b`. Версия без знака (`_mm_cmpgt_epu64`) использует вычитание (`b - a`) для обнаружения заимствования, фильтруемого совпадением старшего бита (MSB), и учитывает случаи, когда `a[MSB] = 1` и `b[MSB] = 0`. Версия со знаком (`_mm_cmpgt_epi64`) использует вычитание для определения знака результата, с аналогичной фильтрацией, и приоритизирует случаи, когда `a[MSB] = 0` и `b[MSB] = 1` (a положительное, b отрицательное). Этот документ консолидирует выводы из нескольких реализаций обеих функций, включая оптимизированную версию, декомпозированную версию с фокусом на MSB и уточнённую реализацию с предварительно вычисленными MSB. Он объясняет логику, рассматривает компромиссы оптимизации, оценивает вычитание против сложения и предоставляет примеры кода для каждого варианта.

## Эволюция Реализаций

### Оптимизированная Реализация

Оптимизированная по производительности версия компактна и применима к сравнениям как без знака, так и со знаком (Little-Endian):

#### Любой (Псевдокод)

```pseudo-code
_cmpgt_epu64(a: 128bit, b: 128bit) -> 128bit {
    result: 128bit = (¬(b ⊕ a)) ∧ (b - a);    // Фильтрация заимствования
    result = result ∨ (a ∧ ¬b);               // Учёт различий MSB (без знака: a[63]=1, b[63]=0)
    result = broadcast_sign(result);
    return shuffle_block::<32>::<3, 3, 1, 1>(result)
}

_cmpgt_epi64(a: 128bit, b: 128bit) -> 128bit {
    result: 128bit = (¬(b ⊕ a)) ∧ (b - a);    // Фильтрация заимствования
    result = result ∨ (¬a ∧ b);               // Учёт различий MSB (со знаком: a[63]=0, b[63]=1)
    result = broadcast_sign(result);
    return shuffle_block::<32>::<3, 3, 1, 1>(result)
}
```

#### x86, x86_64 (Rust)

```rust
unsafe fn _mm_cmpgt_epu64(a: __m128i, b: __m128i) -> __m128i {
    return _mm_shuffle_epi32::<0xF5>(
        _mm_srai_epi32::<0x1F>(
            _mm_or_si128(
                _mm_andnot_si128(_mm_xor_si128(b, a), _mm_sub_epi64(b, a)), // Фильтрация заимствования
                _mm_andnot_si128(b, a)                                      // Учёт различий MSB
            )
        )
    );
}

unsafe fn _mm_cmpgt_epi64(a: __m128i, b: __m128i) -> __m128i {
    return _mm_shuffle_epi32::<0xF5>(
        _mm_srai_epi32::<0x1F>(
            _mm_or_si128(
                _mm_andnot_si128(_mm_xor_si128(b, a), _mm_sub_epi64(b, a)), // Фильтрация заимствования
                _mm_andnot_si128(a, b)                                      // Учёт различий MSB
            )
        )
    );
}
```

- **Преимущества**: Минимизирует количество инструкций (~8 инструкций SSE2: `pxor`, `psubq`, `pandn`, `pandn`, `por`, `psrad`, `pshufd`), используя полные побитовые операции для сравнений со знаком и без.
- **Недостатки**: Обрабатывает все биты в `(¬(b ⊕ a)) ∧ (b - a)` и `a ∧ ¬b` (без знака) или `¬a ∧ b` (со знаком), что скрывает ключевую роль MSB. Это снижает семантическую ясность, так как обнаружение заимствования (без знака) или знака (со знаком) является неявным.
- **Вывод**: Оптимизация отдаёт приоритет производительности над прозрачностью, делая логику менее интуитивной без декомпозиции.

### Декомпозированная Реализация с Фокусом на MSB

Декомпозированная версия явно фокусируется на MSB (`-0x8000000000000000`):

```rust
pub unsafe fn _mm_cmpgt_epu64(a: __m128i, b: __m128i) -> __m128i {
    let diff_signs = _mm_and_si128(_mm_xor_si128(b, a), _mm_set1_epi64x(-0x8000000000000000));
    let sub_signs = _mm_and_si128(_mm_sub_epi64(b, a), _mm_set1_epi64x(-0x8000000000000000));
    let result_signs = _mm_andnot_si128(diff_signs, sub_signs);
    let result_signs = _mm_or_si128(result_signs, _mm_andnot_si128(_mm_and_si128(b, _mm_set1_epi64x(-0x8000000000000000)), _mm_and_si128(a, _mm_set1_epi64x(-0x8000000000000000))));
    return _mm_shuffle_epi32::<0xF5>(_mm_srai_epi32::<0x1F>(result_signs));
}

pub unsafe fn _mm_cmpgt_epi64(a: __m128i, b: __m128i) -> __m128i {
    let diff_signs = _mm_and_si128(_mm_xor_si128(b, a), _mm_set1_epi64x(-0x8000000000000000));
    let sub_signs = _mm_and_si128(_mm_sub_epi64(b, a), _mm_set1_epi64x(-0x8000000000000000));
    let result_signs = _mm_andnot_si128(diff_signs, sub_signs);
    let result_signs = _mm_or_si128(result_signs, _mm_andnot_si128(_mm_and_si128(a, _mm_set1_epi64x(-0x8000000000000000)), _mm_and_si128(b, _mm_set1_epi64x(-0x8000000000000000))));
    return _mm_shuffle_epi32::<0xF5>(_mm_srai_epi32::<0x1F>(result_signs));
}
```

- **Улучшения**: Ограничивает операции MSB, проясняя, что сравнение зависит от заимствования (без знака) или знака (со знаком) и различий MSB. Явные шаги повышают читаемость.
- **Компромисс**: Сохраняет эффективность (~8 инструкций), жертвуя небольшой универсальностью (побитовые операции над всеми битами), которая не требуется для обоих типов сравнения.
- **Вывод**: Декомпозиция восстанавливает семантическую ясность, фокусируясь на MSB, критически важном для результатов сравнения.

### Уточнённая Реализация

Уточнённая реализация предварительно вычисляет значения MSB для максимальной ясности:

```rust
pub unsafe fn _mm_cmpgt_epu64(a: __m128i, b: __m128i) -> __m128i {
    let a_sign = _mm_and_si128(a, _mm_set1_epi64x(-0x8000000000000000));
    let b_sign = _mm_and_si128(b, _mm_set1_epi64x(-0x8000000000000000));

    // Step 1: diff = b ⊕ a (MSB differences)
    let diff_signs = _mm_xor_si128(b_sign, a_sign); // pxor

    // Step 2: sub = b - a (borrow at MSB)
    let sub_signs = _mm_and_si128(_mm_sub_epi64(b, a), _mm_set1_epi64x(-0x8000000000000000)); // psubq

    // Step 3: r = ~(diff) & sub (filter borrow where MSBs match)
    let result_signs = _mm_andnot_si128(diff_signs, sub_signs); // pandn

    // Step 4: r |= a & ~b (account for a[MSB]=1, b[MSB]=0)
    let result_signs = _mm_or_si128(r, _mm_andnot_si128(b_sign, a_sign)); // pandn, por
    
    // Step 5: Propagate sign from 32-bit lanes [3, 1] to 64-bit lanes
    return _mm_shuffle_epi32::<0xF5>(_mm_srai_epi32::<0x1F>(result_signs)); // psrad, pshufd
}

pub unsafe fn _mm_cmpgt_epi64(a: __m128i, b: __m128i) -> __m128i {
    let a_sign = _mm_and_si128(a, _mm_set1_epi64x(-0x8000000000000000));
    let b_sign = _mm_and_si128(b, _mm_set1_epi64x(-0x8000000000000000));

    // Step 1: diff = b ⊕ a (MSB differences)
    let diff_signs = _mm_xor_si128(b_sign, a_sign); // pxor

    // Step 2: sub = b - a (borrow at MSB)
    let sub_signs = _mm_and_si128(_mm_sub_epi64(b, a), _mm_set1_epi64x(-0x8000000000000000)); // psubq

    // Step 3: r = ~(diff) & sub (filter borrow where MSBs match)
    let result_signs = _mm_andnot_si128(diff_signs, sub_signs); // pandn

    // Step 4: r |= ~a & b (account for a[MSB]=0, b[MSB]=1)
    let result_signs = _mm_or_si128(result_signs, _mm_andnot_si128(a_sign, b_sign)); // pandn, por
    
    // Step 5: Propagate sign from 32-bit lanes [3, 1] to 64-bit lanes
    return _mm_shuffle_epi32::<0xF5>(_mm_srai_epi32::<0x1F>(result_signs)); // psrad, pshufd
}
```

- **Улучшения**:
  - Предварительно вычисляет `a_sign` и `b_sign`, выделяя MSB заранее.
  - Чётко обозначает шаги (например, "различия MSB", "заимствование на MSB"), соответствуя логическому потоку.
- **Количество инструкций**: ~9 инструкций (`pand`, `pand`, `pxor`, `psubq`, `pand`, `pandn`, `pandn`, `por`, `psrad`, `pshufd`), чуть больше из-за предварительного вычисления MSB.
- **Вывод**: Приоритизирует ясность, делая реализацию отличной основой для понимания логики SIMD-сравнений для случаев со знаком и без.

## Логика Алгоритма

Обе функции сравнивают 64-битные целые числа в векторах `__m128i`, используя арифметику *дополнения до двух*, но различаются в интерпретации MSB (бит 63).

### Сравнение без знака (`_mm_cmpgt_epu64`)

Обнаруживает заимствование в `b - a` (MSB = 1 указывает на `b < a`) и учитывает случаи, когда `a[63] = 1`, `b[63] = 0`. Шаги:
1. **Извлечение MSB**: Вычисление `a_sign = a & 0x80...`, `b_sign = b & 0x80...`.
2. **Различия MSB**: XOR `b_sign` и `a_sign` для определения различий MSB.
3. **Обнаружение заимствования**: Выполнение `b - a` и извлечение MSB для проверки заимствования.
4. **Фильтрация заимствования**: Сохранение заимствования только при совпадении MSB (`~diff_signs & sub_signs`).
5. **Учёт различий MSB**: Включение случаев, когда `a[63] = 1`, `b[63] = 0` (`a_sign & ~b_sign`).
6. **Распространение маски**: Преобразование MSB в 64-битную маску через сдвиг и перестановку.

### Сравнение со знаком (`_mm_cmpgt_epi64`)

Обнаруживает знак в `b - a` (MSB = 1 указывает на `b - a < 0`, предполагая `a > b`) и учитывает случаи, когда `a[63] = 0`, `b[63] = 1`. Шаги:
1. **Извлечение MSB**: Вычисление `a_sign` и `b_sign` для выделения знакового бита.
2. **Различия MSB**: XOR `b_sign` и `a_sign` для определения различий знаков.
3. **Обнаружение знака**: Выполнение `b - a` и извлечение MSB для проверки, является ли `b - a < 0`.
4. **Фильтрация знака**: Сохранение знакового бита только при совпадении знаков (`~diff_signs & sub_signs`).
5. **Учёт различий знаков**: Включение случаев, когда `a[63] = 0`, `b[63] = 1` (`~a_sign & b_sign`).
6. **Распространение маски**: Преобразование MSB в 64-битную маску.

### Пошаговый Анализ (Пример на 8 битах)

#### Без знака: `a = 0x80` (128), `b = 0x7F` (127)
- **Ожидание**: `a > b` (128 > 127).
- **Шаги**:
  - `a_sign = 0x80`, `b_sign = 0x00`.
  - `diff_signs = 0x80 ⊕ 0x00 = 0x80`.
  - `sub_signs = (0x7F - 0x80 = 0xFF) & 0x80 = 0x80` (заимствование).
  - `r = ¬0x80 & 0x80 = 0x00`.
  - `a_sign & ¬b_sign = 0x80 & 0xFF = 0x80`.
  - `r = 0x00 | 0x80 = 0x80` → `a > b`.
  - Распространение: `_mm_srai_epi32(0x80, 0x1F)` → `0xFFFFFFFF`, `_mm_shuffle_epi32::<0xF5>` → `0xFFFFFFFFFFFFFFFF`.

#### Со знаком: `a = 0x80` (-128), `b = 0x7F` (127)
- **Ожидание**: `a < b` (-128 < 127).
- **Шаги**:
  - `a_sign = 0x80`, `b_sign = 0x00`.
  - `diff_signs = 0x80`.
  - `sub_signs = (0xFF) & 0x80 = 0x80` (отрицательный результат).
  - `r = ¬0x80 & 0x80 = 0x00`.
  - `~a_sign & b_sign = ¬0x80 & 0x00 = 0x00` (a отрицательное, b положительное).
  - `r = 0x00 | 0x00 = 0x00` → `a < b`.
  - Распространение: `_mm_srai_epi32(0x00, 0x1F)` → `0x00000000`, `_mm_shuffle_epi32::<0xF5>` → `0x0000000000000000`.

## Сравнение Реализаций

- **Оптимизированная**: Обрабатывает все биты, оптимизируя производительность (~8 инструкций), но теряет в ясности.
- **Декомпозированная**: Ограничивается MSB, балансируя ясность и эффективность (~8 инструкций).
- **Уточнённая**: Предварительно вычисляет MSB, приоритизируя ясность (~9 инструкций).
- **Эквивалентность**:
  - Оптимизированная: `(¬(b ⊕ a)) ∧ (b - a)` и `a ∧ ¬b` (без знака) или `¬a ∧ b` (со знаком) для всех битов.
  - Декомпозированная: `(b ⊕ a) & 0x80...`, `(b - a) & 0x80...`, `(a ∧ ¬b) & 0x80...` (без знака) или `(¬a ∧ b) & 0x80...` (со знаком).
  - Уточнённая: То же, что декомпозированная, с предварительно вычисленными `a_sign`, `b_sign`.
- **Компромисс**: Уточнённая версия жертвует одной инструкцией ради читаемости.

## Консолидированные Выводы

1. **Вычитание против Сложения**:
   - **Вычитание**:
     - Без знака: Оптимально, так как заимствование (MSB = 1 в `b - a`) указывает на `b < a` (например, `0x00 - 0x01 = 0xFF`, MSB = 1).
     - Со знаком: Оптимально, так как `b - a < 0` (MSB = 1) указывает на `a > b` при совпадении знаков.
   - **Сложение**: Менее подходит для сравнения без знака, так как перенос (`a + b ≥ 2^{64}`) не коррелирует с `a > b` (например, `a = 0x01`, `b = 0xFF...` → перенос, но `1 < 2^{64} - 1`). Для сравнения со знаком обнаружение переполнения добавляет сложность (~3–4 инструкции).
   - **Вывод**: Вычитание проще и прямее для обоих случаев.

2. **Оптимизация против Ясности**:
   - Оптимизированные версии приоритизируют производительность, скрывая фокус на MSB.
   - Декомпозированные и уточнённые версии подчёркивают операции с MSB, повышая читаемость при почти оптимальной производительности.

3. **Дополнение до двух**:
   - **Без знака**: MSB = 1 указывает на большие значения. `a ∧ ¬b` обеспечивает `0x8000000000000000` (2^{63}) > `0x7FFFFFFFFFFFFFFF` (2^{63} - 1).
   - **Со знаком**: MSB = 1 указывает на отрицательные значения. `¬a ∧ b` обеспечивает `0x8000000000000000` (-2^{63}) < `0x7FFFFFFFFFFFFFFF` (2^{63} - 1).
   - Вычитание: `b - a = b + (¬a + 1)` создаёт заимствование (без знака) или отрицательный результат (со знаком) при MSB = 1.

4. **Декомпозиция**:
   - Побитовые операции над всеми битами были декомпозированы, чтобы сосредоточиться на MSB, проясняя обнаружение заимствования (без знака) и знака (со знаком).
   - Предварительное вычисление MSB в уточнённой версии повышает педагогическую ценность.

## Анализ Пограничных Случаев

### Случаи без знака
1. **Случай 1**: `a = 0x8000000000000000` (2^{63}), `b = 0x7FFFFFFFFFFFFFFF` (2^{63} - 1).
   - Ожидание: `a > b`.
   - Уточнённая: `a_sign = 0x80...`, `b_sign = 0x00`, `diff_signs = 0x80...`, `sub_signs = 0x80...`, `r = 0x00 | 0x80... = 0x80...` → `a > b`.

2. **Случай 2**: `a = 0x7FFFFFFFFFFFFFFF` (2^{63} - 1), `b = 0xFFFFFFFFFFFFFFFF` (2^{64} - 1).
   - Ожидание: `a < b`.
   - Уточнённая: `a_sign = 0x00`, `b_sign = 0x80...`, `diff_signs = 0x80...`, `sub_signs = 0x80...`, `r = 0x00 | 0x00 = 0x00` → `a < b`.

3. **Случай 3**: `a = 0x0000000000000001` (1), `b = 0x0000000000000000` (0).
   - Ожидание: `a > b`.
   - Уточнённая: `a_sign = 0x00`, `b_sign = 0x00`, `diff_signs = 0x00`, `sub_signs = 0x80...`, `r = 0x80... | 0x00 = 0x80...` → `a > b`.

### Случаи со знаком
1. **Случай 1**: `a = 0x8000000000000000` (-2^{63}), `b = 0x7FFFFFFFFFFFFFFF` (2^{63} - 1).
   - Ожидание: `a < b`.
   - Уточнённая: `a_sign = 0x80...`, `b_sign = 0x00`, `diff_signs = 0x80...`, `sub_signs = 0x80...`, `r = 0x00 | 0x00 = 0x00` → `a < b`.

2. **Случай 2**: `a = 0xFFFFFFFFFFFFFFFF` (-1), `b = 0xFFFFFFFFFFFFFFFE` (-2).
   - Ожидание: `a > b`.
   - Уточнённая: `a_sign = 0x80...`, `b_sign = 0x80...`, `diff_signs = 0x00`, `sub_signs = 0x80...`, `r = 0x80... | 0x00 = 0x80...` → `a > b`.

3. **Случай 3**: `a = 0x0000000000000001` (1), `b = 0xFFFFFFFFFFFFFFFF` (-1).
   - Ожидание: `a > b`.
   - Уточнённая: `a_sign = 0x00`, `b_sign = 0x80...`, `diff_signs = 0x80...`, `sub_signs = 0x80...`, `r = 0x00 | 0x80... = 0x80...` → `a > b`.

## Производительность и Масштабируемость

- **Количество инструкций**:
  - Оптимизированная: ~8 инструкций.
  - Декомпозированная: ~8 инструкций.
  - Уточнённая: ~9 инструкций (дополнительная `pand` для `a_sign`, `b_sign`).
- **Масштабируемость**: Логика применима к `_mm256_cmpgt_epu64`/`_epi64` (AVX2) и `_mm512_cmpgt_epu64`/`_epi64` (AVX512).
- **Проверка**:
  ```bash
  cargo rustc --release -- --emit asm
  ```

## Рекомендации по Тестированию

```rust
let tests = [
    // Без знака
    (
        _mm_setr_epi64x(0x8000000000000000, 0x7FFFFFFFFFFFFFFF),
        _mm_setr_epi64x(0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF),
        "Пограничные случаи без знака: 0x80... против 0x7F..., 0x7F... против 0xFF...",
    ),
    (
        _mm_setr_epi64x(0x0000000000000001, 0x0000000000000000),
        _mm_setr_epi64x(0x0000000000000000, 0x0000000000000000),
        "Переход через 0x00 без знака: 0x01 против 0x00, равные значения",
    ),
    // Со знаком
    (
        _mm_setr_epi64x(0x8000000000000000, 0x7FFFFFFFFFFFFFFF),
        _mm_setr_epi64x(0x7FFFFFFFFFFFFFFF, 0x8000000000000000),
        "Пограничные случаи со знаком: -2^63 против 2^63-1, 2^63-1 против -2^63",
    ),
    (
        _mm_setr_epi64x(0xFFFFFFFFFFFFFFFF, 0x0000000000000001),
        _mm_setr_epi64x(0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF),
        "Со знаком: -1 против -2, 1 против -1",
    ),
];
```

## Заключение

Реализации `_mm_cmpgt_epu64` и `_mm_cmpgt_epi64` демонстрируют развитие от оптимизированных по производительности до ориентированных на ясность дизайнов. Уточнённые варианты с предварительно вычисленными MSB и корректным сдвигом (`_mm_srai_epi32::<0x1F>`) обеспечивают исключительную читаемость при сохранении почти оптимальной производительности. Ключевые выводы:
- Вычитание оптимально для сравнений без знака (обнаружение заимствования) и со знаком (обнаружение знака).
- Сложение менее надёжно из-за переноса (без знака) или сложности обнаружения переполнения (со знаком).
- Декомпозиция подчёркивает MSB, критически важный для пограничных случаев, таких как `0x8000000000000000` против `0x7FFFFFFFFFFFFFFF`.
- Уточнённые реализации служат как производительными решениями, так и ясными примерами для программирования SIMD, с различием в `a ∧ ¬b` (без знака) и `¬a ∧ b` (со знаком).