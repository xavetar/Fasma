# Унифицированная Логика и Реализация `_mm_cmpgt_epu64` и `_mm_cmpgt_epi64`

Этот документ унифицирует логику функций `_mm_cmpgt_epu64` и `_mm_cmpgt_epi64`, предназначенных для сравнения 64-битных целых чисел без знака и со знаком, соответственно, в двух векторах `__m128i` с использованием встроенных инструкций SSE2. Обе функции сравнивают `a` и `b`, возвращая `0xFFFFFFFFFFFFFFFF` для каждой 64-битной линии, где `a > b`, и `0x0000000000000000`, где `a ≤ b`. Версия без знака (`_mm_cmpgt_epu64`) использует заимствование при вычитании и побитовые операции для обработки сравнений без знака, в то время как версия со знаком (`_mm_cmpgt_epi64`) использует определение знака при вычитании и приоритизирует случаи, когда `a` положительное, а `b` отрицательное. Обе реализации обходят ловушки арифметики *дополнения до двух*, фокусируясь на различиях старшего бита (MSB) и результатах вычитания. Ниже приведён код на C с подробными комментариями и псевдокод в формате markdown.

## Реализация на C с Комментариями

```c
#include <emmintrin.h> // Встроенные инструкции SSE2

// Сравнивает 64-битные целые числа без знака в двух векторах __m128i
// Возвращает: 0xFFFFFFFFFFFFFFFF для каждой 64-битной линии, где a > b, 0x0000000000000000 где a ≤ b
__m128i _mm_cmpgt_epu64(__m128i a, __m128i b) {
    // 1. Извлечение MSB (бит 63) для обоих входов для фокусировки на различиях старшего бита
    //    - Маска: 0x8000000000000000 выделяет самый старший бит
    __m128i msb_mask = _mm_set1_epi64x(0x8000000000000000);
    __m128i a_sign = _mm_and_si128(a, msb_mask); // a_sign = a & 0x8000...
    __m128i b_sign = _mm_and_si128(b, msb_mask); // b_sign = b & 0x8000...

    // 2. Вычисление различий в MSB (где a и b различаются в бите 63)
    //    - XOR: 1, где биты различаются, 0, где они одинаковы
    __m128i diff_signs = _mm_xor_si128(b_sign, a_sign); // diff_signs = b_sign ⊕ a_sign

    // 3. Выполнение вычитания (b - a) и выделение MSB для обнаружения заимствования
    //    - Заимствование (MSB = 1 в результате) указывает на b < a, следовательно, a > b в контексте без знака
    __m128i sub = _mm_sub_epi64(b, a); // sub = b - a
    __m128i sub_signs = _mm_and_si128(sub, msb_mask); // sub_signs = (b - a) & 0x8000...

    // 4. Фильтрация заимствования для случаев, когда MSB a и b совпадают
    //    - ANDNOT: ¬diff_signs ∧ sub_signs гарантирует, что заимствование учитывается только при a[63] == b[63]
    //    - Это предотвращает ложные срабатывания при различиях MSB (например, a = 0x7F..., b = 0x80...)
    __m128i result = _mm_andnot_si128(diff_signs, sub_signs); // result = ¬diff_signs ∧ sub_signs

    // 5. Учёт случаев, когда a[63] = 1 и b[63] = 0 (например, a = 0x80..., b = 0x7F...)
    //    - ANDNOT: a_sign ∧ ¬b_sign фиксирует a > b, когда у a установлен MSB, а у b нет
    //    - Критично для пограничных случаев, таких как 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF
    result = _mm_or_si128(result, _mm_andnot_si128(b_sign, a_sign)); // result |= a_sign ∧ ¬b_sign

    // 6. Распространение MSB результата на все 64 бита в каждой линии
    //    - Арифметический сдвиг вправо (psrad) на 31 заполняет 32-битные линии знаковым битом
    //    - Перестановка (pshufd) дублирует старшие 32 бита для заполнения 64-битной линии
    //    - _MM_SHUFFLE(3,3,1,1) = 0xF5 обеспечивает правильное выравнивание линий
    result = _mm_srai_epi32(result, 31); // Расширение знака MSB на 32 бита
    result = _mm_shuffle_epi32(result, _MM_SHUFFLE(3, 3, 1, 1)); // Дублирование для заполнения 64 бит

    return result;
}

// Сравнивает 64-битные целые числа со знаком в двух векторах __m128i
// Возвращает: 0xFFFFFFFFFFFFFFFF для каждой 64-битной линии, где a > b, 0x0000000000000000 где a ≤ b
__m128i _mm_cmpgt_epi64(__m128i a, __m128i b) {
    // 1. Извлечение MSB (бит 63, знаковый бит) для обоих входов для фокусировки на различиях знака
    //    - Маска: 0x8000000000000000 выделяет знаковый бит
    __m128i msb_mask = _mm_set1_epi64x(0x8000000000000000);
    __m128i a_sign = _mm_and_si128(a, msb_mask); // a_sign = a & 0x8000...
    __m128i b_sign = _mm_and_si128(b, msb_mask); // b_sign = b & 0x8000...

    // 2. Вычисление различий в знаковых битах (где a и b различаются в бите 63)
    //    - XOR: 1, где знаки различаются, 0, где они одинаковы
    __m128i diff_signs = _mm_xor_si128(b_sign, a_sign); // diff_signs = b_sign ⊕ a_sign

    // 3. Выполнение вычитания (b - a) и выделение MSB для обнаружения знака
    //    - Отрицательный результат (MSB = 1) указывает на b - a < 0, следовательно, a > b в контексте со знаком
    __m128i sub = _mm_sub_epi64(b, a); // sub = b - a
    __m128i sub_signs = _mm_and_si128(sub, msb_mask); // sub_signs = (b - a) & 0x8000...

    // 4. Фильтрация знака для случаев, когда знаки a и b совпадают
    //    - ANDNOT: ¬diff_signs ∧ sub_signs гарантирует, что знак учитывается только при a[63] == b[63]
    //    - Это предотвращает ложные срабатывания при различиях знаков (например, a = -1, b = 1)
    __m128i result = _mm_andnot_si128(diff_signs, sub_signs); // result = ¬diff_signs ∧ sub_signs

    // 5. Учёт случаев, когда a[63] = 0 и b[63] = 1 (например, a = 0x7F..., b = 0x80...)
    //    - ANDNOT: ¬a_sign ∧ b_sign фиксирует a > b, когда a положительное, а b отрицательное
    //    - Критично для пограничных случаев, таких как 0x7FFFFFFFFFFFFFFF > 0x8000000000000000
    result = _mm_or_si128(result, _mm_andnot_si128(a_sign, b_sign)); // result |= ¬a_sign ∧ b_sign

    // 6. Распространение MSB результата на все 64 бита в каждой линии
    //    - Аналогично версии без знака: сдвиг и перестановка для создания полной 64-битной маски
    result = _mm_srai_epi32(result, 31); // Расширение знака MSB на 32 бита
    result = _mm_shuffle_epi32(result, _MM_SHUFFLE(3, 3, 1, 1)); // Дублирование для заполнения 64 бит

    return result;
}
```

## Логика Псевдокода

Методы `_mm_cmpgt_epu64` и `_mm_cmpgt_epi64` сравнивают 64-битные целые числа без знака и со знаком, соответственно, в двух векторах `__m128i`, анализируя результаты вычитания (заимствование для версии без знака, знак для версии со знаком) и различия MSB. Ниже приведена пошаговая логика для обеих функций:

### `_mm_cmpgt_epu64` (Без знака)
1. **Извлечение MSB (бит 63)**:
   - Вычисление `a_sign = a & 0x8000000000000000`.
   - Вычисление `b_sign = b & 0x8000000000000000`.
   - *Цель*: Фокусировка на старшем бите, так как он определяет сравнения без знака (например, `0x8000...` > `0x7FFF...`).

2. **Вычисление различий MSB**:
   - Вычисление `diff_signs = b_sign ⊕ a_sign`.
   - *Цель*: Определение линий, где `a` и `b` имеют разные MSB (1, если разные, 0, если одинаковые). Это фильтрует случаи заимствования.

3. **Обнаружение заимствования через вычитание**:
   - Вычисление `sub = b - a`.
   - Вычисление `sub_signs = sub & 0x8000000000000000`.
   - *Цель*: Заимствование (MSB = 1) указывает на `b < a`, следовательно, `a > b`.

4. **Фильтрация заимствования для одинаковых MSB**:
   - Вычисление `result = ¬diff_signs ∧ sub_signs`.
   - *Цель*: Учёт заимствования только при одинаковых MSB у `a` и `b`, предотвращая ложные срабатывания (например, `a = 0x7F...`, `b = 0x80...`).

5. **Обработка различных MSB**:
   - Вычисление `result |= a_sign ∧ ¬b_sign`.
   - *Цель*: Фиксация случаев, когда `a[63] = 1`, `b[63] = 0` (например, `0x8000...` > `0x7FFF...`).

6. **Распространение результата**:
   - Арифметический сдвиг вправо на 31 бит для заполнения 32-битных линий.
   - Перестановка для дублирования старших 32 бит по 64-битным линиям.
   - *Цель*: Преобразование MSB в полную 64-битную маску (`0xFFFFFFFFFFFFFFFF` или `0x0000000000000000`).

### `_mm_cmpgt_epi64` (Со знаком)
1. **Извлечение MSB (бит 63, знаковый бит)**:
   - Вычисление `a_sign = a & 0x8000000000000000`.
   - Вычисление `b_sign = b & 0x8000000000000000`.
   - *Цель*: Фокусировка на знаковом бите, критически важном для сравнений со знаком (например, `0x7FFF...` > `0x8000...`).

2. **Вычисление различий знаковых битов**:
   - Вычисление `diff_signs = b_sign ⊕ a_sign`.
   - *Цель*: Определение линий, где `a` и `b` имеют разные знаки.

3. **Обнаружение знака через вычитание**:
   - Вычисление `sub = b - a`.
   - Вычисление `sub_signs = sub & 0x8000000000000000`.
   - *Цель*: Отрицательный результат (MSB = 1) указывает на `b - a < 0`, следовательно, `a > b`.

4. **Фильтрация знака для одинаковых знаков**:
   - Вычисление `result = ¬diff_signs ∧ sub_signs`.
   - *Цель*: Учёт отрицательного результата только при одинаковых знаках `a` и `b`, предотвращая ложные срабатывания (например, `a = -1`, `b = 1`).

5. **Обработка различных знаков**:
   - Вычисление `result |= ¬a_sign ∧ b_sign`.
   - *Цель*: Фиксация случаев, когда `a[63] = 0`, `b[63] = 1` (a положительное, b отрицательное, например, `0x7FFF...` > `0x8000...`).

6. **Распространение результата**:
   - Аналогично версии без знака: сдвиг и перестановка для создания 64-битной маски.

## Ключевые Выводы

- **Сравнение на основе вычитания**:
  - **Без знака**: Заимствование (MSB = 1 в `b - a`) надёжно определяет `a > b`, в отличие от сложения, требующего сложной обработки переноса.
  - **Со знаком**: Отрицательный результат (MSB = 1 в `b - a`) указывает на `a > b` при совпадении знаков, с `¬a_sign ∧ b_sign` для обработки разных знаков.
- **Фокус на MSB**:
  - **Без знака**: MSB = 1 указывает на большие значения (например, `0x8000...` > `0x7FFF...`).
  - **Со знаком**: MSB = 1 указывает на отрицательные значения (например, `0x8000...` < `0x7FFF...`).
- **Побитовые операции**: `⊕`, `∧`, `¬`, `∨` эмулируют отсутствующие инструкции сравнения в SSE2, сохраняя низкое количество инструкций (~9).
- **Обработка пограничных случаев**:
  - **Без знака**: `a_sign ∧ ¬b_sign` обеспечивает `0x8000000000000000` > `0x7FFFFFFFFFFFFFFF`.
  - **Со знаком**: `¬a_sign ∧ b_sign` обеспечивает `0x7FFFFFFFFFFFFFFF` > `0x8000000000000000`.
- **Дополнение до двух**:
  - **Без знака**: Игнорирует переполнение со знаком, рассматривая все операции как без знака.
  - **Со знаком**: Использует знаковый бит и результат вычитания для сохранения правильного порядка.
- **Унифицированная логика**: Обе функции имеют одинаковую структуру, различаясь только в термине различия MSB (`a_sign ∧ ¬b_sign` против `¬a_sign ∧ b_sign`).

## Производительность
- **Количество инструкций**: ~9 инструкций (`pand x3`, `pxor`, `psubq`, `pandn x2`, `por`, `psrad`, `pshufd`) для обеих функций.
- **Масштабируемость**: Логика применима к AVX2 (`_mm256_cmpgt_epu64`/`_epi64`) и AVX512 (`_mm512_cmpgt_epu64`/`_epi64`) с минимальными корректировками.
- **Оптимизация**: Предварительное вычисление `a_sign` и `b_sign` повышает ясность с минимальным влиянием на производительность.

## Рекомендации по Тестированию

Для проверки корректности протестируйте следующие пограничные случаи:
- **Без знака**:
  - `a = 0x8000000000000000`, `b = 0x7FFFFFFFFFFFFFFF` (ожидается `a > b`).
  - `a = 0x7FFFFFFFFFFFFFFF`, `b = 0xFFFFFFFFFFFFFFFF` (ожидается `a < b`).
  - `a = 0x0000000000000001`, `b = 0x0000000000000000` (ожидается `a > b`).
- **Со знаком**:
  - `a = 0x8000000000000000` (-2^{63}), `b = 0x7FFFFFFFFFFFFFFF` (2^{63} - 1) (ожидается `a < b`).
  - `a = 0xFFFFFFFFFFFFFFFF` (-1), `b = 0xFFFFFFFFFFFFFFFE` (-2) (ожидается `a > b`).
  - `a = 0x0000000000000001` (1), `b = 0xFFFFFFFFFFFFFFFF` (-1) (ожидается `a > b`).

Эта унифицированная реализация балансирует читаемость и производительность, делая её подходящей как для производственных, так и для образовательных целей. Она обрабатывает все пограничные случаи (например, `0x8000...`, `0x7FFF...`, `0xFFFF...`) и устойчива к переполнениям в *дополнении до двух* для сравнений как без знака, так и со знаком.